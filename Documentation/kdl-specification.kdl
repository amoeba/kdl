` KDL Specification 1.0

` This is the primary specification on KDL, and defines/specifies the language
` through examples. The first section of this document will define the basic
` tokens/lexemes of the language.

` §1 SCALAR TYPES --------------------------------------------------------------
` §1.1 - INTEGERS --------------------------------------------------------------
` Integers are a fundamental type in any language. Due to the close association
` with the Classic Macintosh and the Resource Manager, KDL defines its integer
` type symbols as so.

`  1	   2	   4	   8
DBYT	DWRD	DLNG	DQAD
HBYT	HWRD	HLNG	HQAD

` These symbols are purely used for type definitions and will not really be used
` in general use.
` Using an integer is fairly standard and as one would expect it to be.

	100
	-42
	0xCA
	0x23D2

` §1.2 - STRINGS ---------------------------------------------------------------
` Strings are another fundamental type in most languages. Strings in KDL can 
` represent a number of different underlying types of string, and depending on
` the situation will be encoded as a specific type of string. These underlying
` String types are:
` 
` 	- Pascal String (Leading length byte followed by characters)
`	- Long Pascal String (Leading length word followed by characters)
` 	- Fixed width string (Characters of string padded/truncated to the width)
`	- C String (Characters of string terminated by a NUL byte)
`
` Representing a string in code is simple however, and done like so:

	"Hello, World!"

` Adjacent strings will be concatanted together, meaning that the following:

	"Hello, "
	"World!"

` Will actually be seen as:

	"Hello, World!"

` §1.3 - RESOURCE ID -----------------------------------------------------------
` Resource ID's are semantically distinct from integers in so far as what they
` represent. Whilst the two are interchangable as a raw value, an integer can
` not be used to identify a resource. A Resource ID can be represented in a
` number of different ways.
`
`	Generic ID (A basic numeric ID, that could represent any type of resource)
	#128

` 	Specific ID (A numeric ID with an associated type)
	Foo.#128

` 	Inline Definition (Create a resource and capture a reference to it)
	new { ... }

` §2 ASSEMBLER MACROS/INSTRUCTIONS ---------------------------------------------
` KDL defines a number of macros and instructions that can be used to instruct
` the assembler to do something. All assembler macros and instructions begin 
` with a '@' symbol.

` §2.1 - OUT INSTRUCTION -------------------------------------------------------
` This instruction is purely for debugging purposes and can be considered 
` optional in an implementation of KDL. It simply echos an string value to the
` standard output of the assembler. The @out instruction should append a newline
` character to the end of the output.
	
	@out "Hello, World!";

` §2.2 - IMPORT INSTRUCTION ----------------------------------------------------
` The implementation of this instruction is required. It tells the assembler to
` import the specified file to the location of the @import instruction.

	@import "some-file.kdl";

` §3 TYPE DEFINITION -----------------------------------------------------------
` KDL is designed to be fully extensible and allow for resource types to be
` defined at runtime, bypassing the need to bake in type definitions.
` A type definition can be started using the following syntax.

@type TypeName : 'code' { ... };

` The _TypeName_ here is the name that will be used by KDL to reference the type
` It is not particularly important, beyond how the type will be referenced.
` The _code_ is never seen elsewhere with KDL, but is used by the assembler
` when encoding a resource file, as the Resource Type code. A resource code must
` be 4 characters long.
`
` An example type definition for the 'VERS' resource.

@type Version : 'VERS' { ... };

` The contents of the '{' braces '}' is used by the assembler to determine what
` the type is and what is used to represent it.

` §3.1 - TEMPLATE --------------------------------------------------------------
` The template is a structure with in a type, that defines the underlying binary
` structure of the resource type. This resembles the 'TMPL' resource that was
` used to define custom resource types.
`
` A template is started as such:

@type SpriteAnimation : 'spïn' {
	template {
		DWRD spritesID;
		DWRD masksID;
		DWRD xSize;
		DWRD ySize;
		DWRD xTiles;
		DWRD yTiles;
	};
};

` The template is comprised of a number of fields. These fields take the form
` of:

	TYPE name;

` The type can be any of the following:
`	- DBYT	Signed 8-bit value (-128 - 127)
`	- DWRD	Signed 16-bit value (-32768 - 32767)
`	- DLNG	Signed 32-bit value (-2147483648 - 2147483647)
`	- DQAD	Signed 64-bit value (-9223372036854775808 - 9223372036854775807)
`	- HBYT	Unsigned 8-bit value (0 - 255)
`	- HWRD	Unsigned 16-bit value (0 - 65535)
`	- HLNG	Unsigned 32-bit value (0 - 4294967295)
`	- HQAD	Unsigned 64-bit value (0 - 18446744073709551615)
`	- PSTR	Pascal String (leading byte for string length)
`	- CSTR	C String (terminating NUL byte)
`	- Cxxx	Fixed width string (xxx bytes wide)
`	- RECT	4 DWRD values (top, left, bottom, right)
` 	- HEXD	Remaining bytes in resource (must be last)

` The names given to each field can be referenced later in the type definition.

` §3.2 - FIELD DEFINITION ------------------------------------------------------
` Type definitions can also contain a number of field defintions. These are used
` to tell KDL how a resource might be declared, what default values it should
` use, and symbol definitions to represent obscure or cryptic values.

@type SpriteAnimation : 'spïn' {
	` A field with a single required value
	field("sprites") as & {
		spritesID;
	};

	` A field with a multiple required values
	field("size") {
		xSize;
		ySize;
	};

	` A field with an optional value
	field("masks") as Picture&  {
		masksID = -1;
	};

	` A field with two optional values.
	field("tiles") {
		xTiles = 6;
		yTiles = 6;
	};
};

` There is quite a lot to break down here. First of all let's take a look at the
` actual field definition:

	field("sprites") as &

` The leading _field_ here is spelling. It tells the assembler that we are 
` beginning a field definition. The parentheses contain a string which is the
` name of the field. This name will be used by others when declaring a resource,
` and is how KDL will reference the field.
` The terminate `as &` needs a little bit more in depth explanation. By default
` KDL will infer the type of the field based on the values that it comprises of.
` In the instance of the "size" field, the type would be a tuple of `DWRD DWRD`.
` By default KDL would interpret "sprites" to be of type `DWRD`. However here,
` we actually want it to be a resource reference, so we add the `as &` to it. We
` could explicitly state the type like so:

	field("sprites") as DWRD

` but this would be unnecessary.
` The '&' in this context is used to represent a generic resource reference. As
` in we do not know what type of resource this might be. This should be used
` when the reference could be any one of multiple resource types. Adding a 
` leading type name to the '&' will specialise the type of reference required.
`
`	&			Generic resource reference
`	Picture&	Reference to a Picture resource.

` Inside the field definition are value definitions. These are simply references
` to fields within the template. The values can be given default values (and 
` thus become optional).
`
`	xTiles; 	This value is required as it has no default value specified.
` 	xTiles = 0;	This value is not required as it has a default value specified.
`
` Another consideration with values is the ability to specify symbols for them.
` Symbols are predefined values that can be used with them. Symbols are defined
` like so:

	xTiles [
		standard = 6,
		extra = 12,
	];

	yTiles = standard [
		standard = 6,
		extra = 12,
	];

` §3.3 - FILE CONTENTS ---------------------------------------------------------
` This is a special type of field that can be defined, that imports the contents
` of a file and writes them to the value of that field. Let's take a look at an
` example resource type:

	@type Picture : 'PICT' {
		template {
			HEXD data;
		};

		field("path") as File {
			data;
		};
	};

` This type of field is simply defined by having a type of `File`.

` §4 RESOURCE DECLARATIONS -----------------------------------------------------

